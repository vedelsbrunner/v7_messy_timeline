<!DOCTYPE html>

<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BC5HBTZTQW"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-BC5HBTZTQW');
    </script>
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <script src="//d3js.org/d3.v6.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"
        integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
        integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
        crossorigin="anonymous"></script>
    <script src="bootstrap3-typeahead.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-beta.1/dist/css/select2.min.css" rel="stylesheet" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-beta.1/dist/js/select2.min.js"></script>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
        integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous" />
    <link href="https://fonts.googleapis.com/css?family=Karla:400,700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="css/index.css" />
    <!-- Local link to badge-lib build (cache-busted for local dev) -->
    <script type="module" src="vis-badge.js?v=dev1"></script>

</head>

<body>
    <div class="container-fluid">

        <div id="agt_tooltip"></div>
        <img id="title_img" src="data/logo.jpg" alt="PeaceRep Logo" />

        <div class="form-group" style="position: absolute; top: 8px; left: 67px;">
            <select id='selUser' style='width: 215px;'>
                <option value="0">Peace Process</option>
            </select>
            <input type='button' value='Go' id='but_read'>
        </div>

        <h3 id="main_title" style="text-align: center; padding-top: 8px;">Back and Forth in Peace Negotiations</h3>
        <!-- Legacy info icon (replaced by vis-badge; kept for reference) -->
        <!-- <button title="Information" id="info_button"><i class="fa fa-info"></i></button> -->
        <vis-badge id="messy_timeline_badge" type="mini" variant="filled"></vis-badge>
        <!-- badges replacement (disabled for now; kept for reference) -->
        <!-- <div id="top_right_badges" class="top-right-badges"></div> -->
        <button class="button button1"><i class="fa fa-refresh"></i></button>
        <div id="bottom_right_badges" class="bottom-right-badges" aria-label="Timeline hints"></div>
        <div id="info" style="font-size: 14px;">
            <p>This visualisation shows the trajectory of all formal agreements in peace
                processes from 1990-2024.
                The blue line represents how a peace process would look if it smoothly went from one stage to the next.
                However, processes do not tend to follow this linear pattern.
                Click the visualisation to start and see how processes go back and forth.</p>
            <p>This visualisation illustrates all processes in version 9 of the PA-X Peace
                Agreements Database, accessible from: <a target="_blank"
                    href="https://www.peaceagreements.org">www.peaceagreements.org</a>.
            </p>
            <p></p>
            <p style="font-size: 12px;">Credits: Tobias Kauer for original visualisation design & Tomas Vancisin for
                v2 updates at PeaceRep (University of Edinburgh).
            </p>
        </div>

        <div class="row">
            <div class="col-md-12 col-sm-12">
                <div class="row">
                    <div class="col-md-12">
                        <div id="chart"></div>
                    </div>
                </div>
            </div>
        </div>

    </div>
    <script>
        'use strict'
        var parseTime = d3.timeParse("%Y-%m-%d");
        var width = document.getElementById('chart').clientWidth
        var margin = 150
        var bottomBadgesReservedPx = 14
        var height = window.innerHeight - 60 - bottomBadgesReservedPx
        var fixed = null
        var ideal = { show: true };

        var sequence = [
            { "key": "Cea", "name": ["Ceasefire", "related"], "color": d3.rgb(241, 80, 31, .8), 'position': 5 },
            { "key": "Pre", "name": ["Pre-negotiation", "process"], "color": d3.rgb(251, 173, 68, .8), 'position': 4 },
            { "key": "SubPar", "name": ["Partial", "Framework-substantive"], "color": d3.rgb(252, 202, 70, .8), 'position': 3 },
            { "key": "SubComp", "name": ["Comprehensive", "Framework-substantive"], "color": d3.rgb(172, 176, 140, .8), 'position': 2 },
            { "key": "Imp", "name": ["Implementation", "Renegotiation/Renewal"], "color": d3.rgb(74, 144, 226, .8), 'position': 1 },
            { "key": "Ren", "name": [], "color": d3.rgb(74, 144, 226, 8), 'position': 1 },
        ]

        // $.ajax({
        // 	method: 'GET',
        // 	url: 'https://test.pax.peaceagreements.org/api/agreements/?format=json',
        // 	dataType: 'jsonp', //change the datatype to 'jsonp' works in most cases
        // 	success: (res) => {
        // 		console.log(res);
        // 	}
        // })

        // d3.json("https://test.pax.peaceagreements.org/api/agreements/?format=json", d => init(d.results))
        // d3.csv("agreements-small-june-2019.csv", d => init(d))

        //URLs for different selections
        document.addEventListener('DOMContentLoaded', (event) => {
            const urlParams = new URLSearchParams(window.location.search);
            const subset = urlParams.get('subset');
            let id, name;

            if (subset) {
                let deconstruct = subset.split("_")
                id = deconstruct[0]
                name = deconstruct[1]

            }
            else {
                id = null
                name = null
            }
            loadData(id)
        });

        function loadData(ppid) {

            Promise.all([
                d3.csv("data/pax_all_agreements_v9.csv"),
            ]).then(d => init(d))

            function init(pax) {
                pax = pax[0]
                //Filter & Sort agreement data
                pax = pax.filter((d, i) => d.Stage !== "Oth")
                pax.sort(function (a, b) {
                    function getDate(d) { return parseTime(d.Dat) }
                    return getDate(a) - getDate(b)
                })

                //Create Objects for Agreements in the same process
                var data = {
                    "ideal": [
                        { "Dat": "1990-01-01", "PPName": "ideal", "Stage": "Cea" },
                        { "Dat": "1999-01-01", "PPName": "ideal", "Stage": "Pre" },
                        { "Dat": "2006-01-01", "PPName": "ideal", "Stage": "SubPar" },
                        { "Dat": "2014-01-01", "PPName": "ideal", "Stage": "SubComp" },
                        { "Dat": "2022-01-01", "PPName": "ideal", "Stage": "Ren" },
                        { "Dat": "2024-01-01", "PPName": "ideal", "Stage": "Ren" }]
                }

                pax.forEach(function (agreement) {
                    if (typeof sequence.find(x => x.key == agreement.Stage) !== 'undefined') sequence.find(x => x.key == agreement.Stage).count++
                    var name = agreement["PPName"]
                    if (typeof data[name] === 'undefined') data[name] = []
                    data[name].push(agreement)
                })

                console.log(pax);

                //create canvas
                var svg = d3.select("#chart")
                    .append("svg")
                    .attr("id", "svg")
                    .attr("viewBox", "0 0 " + width + " " + height)
                    .attr("preserveAspectRatio", "xMidYMid meet")

                //Scales & Axes
                var scaleColor = d3.scaleLinear()
                    .domain([-350, 0, 350])
                    .range([d3.rgb("#0075FF"), d3.rgb("#555555"), d3.rgb("#FF3B00")])
                var scaleY = d3.scaleLinear()
                    .domain(d3.extent(sequence, d => d.position))
                    .range([20, height - 10])
                var scaleX = d3.scaleTime()
                    .domain([parseTime("1990-01-01"), parseTime("2025-01-01")])
                    .range([0, width - margin])
                    .nice()
                var xAxis = d3.axisTop(scaleX).ticks(4);
                var years = svg
                    .append("g")
                    .attr("class", "axis axis--x")
                    .attr("transform", "translate(20,20)")
                    .call(xAxis);


                //legend
                var legend = svg.append("g")
                    .attr("class", "lines")
                    .selectAll("g")
                    .data(sequence).enter()
                    .append("text")
                    .attr("y", d => scaleY(d.position) - 20)
                    .attr("font-size", "10pt")
                    .attr("text-anchor", "start")
                    .selectAll("tspan").data(d => d.name).enter().append("tspan")
                    .text(d => d)
                    .attr("x", width - margin)
                    .attr("dy", "10pt")

                //compute line segments
                var segment = function (d, i, scale) {
                    if (i < data[d.PPName].length - 1) {
                        var start = {
                            "x": Math.round(scale(parseTime(d.Dat))),
                            "y": scaleY(sequence.find(x => x.key == d.Stage).position)
                        }
                        var stop = {
                            "x": Math.round(scale(parseTime(data[d.PPName][i + 1].Dat))),
                            "y": scaleY(sequence.find(x => x.key == data[d.PPName][i + 1].Stage).position)
                        }
                        var distance = (stop.x - start.x) / 1.5
                        return "M " + start.x + " " + start.y + " C " + (start.x + distance) + " " + start.y + ", " + (stop.x - distance) + " " + stop.y + ", " + stop.x + " " + stop.y
                    }
                }

                //draw paths for data
                svg.append("clipPath")
                    .attr("id", "ellipse-clip")
                    .append("rect")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("width", width - margin - 10)
                    .attr("height", height);  //clipPath for zoomed data

                var container = svg.append("g")
                    .attr("class", "processes")
                    .attr("clip-path", "url(#ellipse-clip)")
                    .attr("pointer-events", "all")
                    .attr("transform", `translate(5,0)`);
                //.on("click",d=>{console.log(d)})

                var process = container.selectAll("g")
                    .data(Object.entries(data)).enter()
                    .append("g")
                    .attr("class", d => "PP-" + d[1][0].PP)
                    .selectAll("path").data(d => d[1])
                    .enter()

                var processPath = process.append("path")
                    .attr("pointer-events", "none")
                    .attr("fill-opacity", 0)
                    .attr("stroke-width", 1)
                    .attr("stroke-linecap", "round")
                    .attr("stroke-opacity", 0.05)
                    .attr("d", (d, i) => segment(d, i, scaleX))
                    .attr("stroke", (d, i) => {
                        if (i < data[d.PPName].length - 1) {
                            var tendency = scaleY(sequence.find(x => x.key == data[d.PPName][i + 1].Stage).position) - scaleY(sequence.find(x => x.key == d.Stage).position)
                            return scaleColor(tendency)
                        }
                    })


                function groupByCountry(data) {
                    return data.sort((a, b) => {
                        if (a.Con < b.Con) {
                            return -1;
                        }
                        if (a.Con > b.Con) {
                            return 1;
                        }
                        // If the countries are the same, sort by date
                        if (a.Dat < b.Dat) {
                            return -1;
                        }
                        if (a.Dat > b.Dat) {
                            return 1;
                        }
                        // If the dates are the same, sort by stage
                        if (a.Stage < b.Stage) {
                            return -1;
                        }
                        if (a.Stage > b.Stage) {
                            return 1;
                        }
                        return 0;
                    });
                }

                let current_year = "_";
                let current_stage = "_";
                let current_conflict = "";
                let same_counter = 0;

                let groupedData = groupByCountry(pax);

                //draw circles for each agreement
                var circles = svg.append("g")
                    .attr("transform", `translate(5,0)`)
                    .attr("class", "circles")
                    .selectAll("circle")
                    .data(groupedData)
                    .join("circle")
                    .attr("class", d => "PP-" + d.PP)
                    .attr("cx", function (d) {
                        return Math.round(scaleX(parseTime(d.Dat)))
                    })
                    .attr("cy", function (d) {
                        if (d.Dat !== current_year && d.Stage !== current_stage) {
                            same_counter = 0;
                            current_year = d.Dat
                            current_stage = d.Stage
                            return scaleY(sequence.find(x => x.key == d.Stage).position)
                        }
                        else if (d.Dat == current_year && d.Stage !== current_stage) {
                            same_counter = 0;
                            current_year = d.Dat
                            current_stage = d.Stage
                            return scaleY(sequence.find(x => x.key == d.Stage).position)
                        }
                        else if (d.Dat !== current_year && d.Stage == current_stage) {
                            same_counter = 0;
                            current_year = d.Dat
                            current_stage = d.Stage
                            return scaleY(sequence.find(x => x.key == d.Stage).position)
                        }
                        else {
                            same_counter += 7;
                            current_year = d.Dat
                            current_stage = d.Stage
                            return scaleY(sequence.find(x => x.key == d.Stage).position) - same_counter;
                        }
                    })
                    .attr("r", function (d, i) {
                        return 5
                    })
                    .attr("stroke", "black")
                    .attr("stroke-width", 1)
                    .attr("fill", "gray")
                    .attr("fill-opacity", .5)
                    .attr("opacity", 0)
                    .attr("pointer-events", "none")
                    .on("mouseover", function (event, i) {
                        const tooltipSel = d3.select("#agt_tooltip");
                        tooltipSel
                            .style("display", "block")
                            .html("<strong>" + i.Dat + ":</strong> " + i.Agt);

                        const tooltipNode = tooltipSel.node();
                        const toolWidth = tooltipNode ? tooltipNode.offsetWidth : 200;
                        const toolHeight = tooltipNode ? tooltipNode.offsetHeight : 60;

                        let x = event.pageX + 15;
                        let y = event.pageY + 15;

                        if (x + toolWidth > window.innerWidth - 10) x = event.pageX - toolWidth - 15;
                        if (y + toolHeight > window.innerHeight - 10) y = event.pageY - toolHeight - 15;

                        tooltipSel
                            .style("left", x + "px")
                            .style("top", y + "px");

                        d3.select(this)
                            .transition()
                            .duration(50)
                            .attr("r", 8);
                    })
                    .on("mousemove", function (event) {
                        const tooltipSel = d3.select("#agt_tooltip");
                        if (tooltipSel.style("display") !== "block") return;

                        const tooltipNode = tooltipSel.node();
                        const toolWidth = tooltipNode ? tooltipNode.offsetWidth : 200;
                        const toolHeight = tooltipNode ? tooltipNode.offsetHeight : 60;

                        let x = event.pageX + 15;
                        let y = event.pageY + 15;

                        if (x + toolWidth > window.innerWidth - 10) x = event.pageX - toolWidth - 15;
                        if (y + toolHeight > window.innerHeight - 10) y = event.pageY - toolHeight - 15;

                        tooltipSel
                            .style("left", x + "px")
                            .style("top", y + "px");
                    })
                    .on("mouseout", function () {
                        d3.select("#agt_tooltip").style("display", "none");
                        d3.select(this)
                            .transition()
                            .duration(50)
                            .attr("r", 5);
                    })

                // Keep this state even though the legacy info button is disabled.

                let counter_collab = 0;

                /*
                // Legacy info icon click handler (replaced by `#messy_timeline_badge`; kept for reference)
                d3.select("#info_button").on("click", function () {
                    counter_collab += 1;
                    if (counter_collab % 2 !== 0) {
                        d3.select("#info")
                            .style("right", 5 + "px")
                    }
                    else {
                        d3.select("#info")
                            .style("right", -305 + "px")
                    }
                })
                */

                // Replacement: mini info badge "Messy Timeline"
                const howToReadBadge = document.getElementById("messy_timeline_badge");
                const howToReadInfoEl = document.getElementById("info");
                const howToReadParagraphs = howToReadInfoEl ? Array.from(howToReadInfoEl.querySelectorAll("p")) : [];
                const howToReadText = howToReadParagraphs
                    .map((p) => (p && p.innerText ? p.innerText : "").trim())
                    .filter(Boolean)
                    .join("\n\n\n");
                const HOW_TO_READ_URL = "https://www.peaceagreements.org";

                function openHowToReadLink(e) {
                    if (e && e.preventDefault) e.preventDefault();
                    if (e && e.stopPropagation) e.stopPropagation();
                    window.open(HOW_TO_READ_URL, "_blank", "noopener,noreferrer");
                }

                if (howToReadBadge) {
                    howToReadBadge.badge = {
                        type: "mini",
                        variant: "filled",
                        label: "Messy Timeline",
                        description: howToReadText,
                        actionIcon: "ExternalLink",
                        actionText: "Click to open www.peaceagreements.org",
                        color: "rgb(2, 136, 209)",
                        icon: "Info"
                    };
                    howToReadBadge.style.cursor = "pointer";
                    howToReadBadge.setAttribute("role", "button");
                    howToReadBadge.setAttribute("tabindex", "0");
                    howToReadBadge.addEventListener("click", openHowToReadLink);
                    howToReadBadge.addEventListener("keydown", (e) => {
                        if (e.key === "Enter" || e.key === " ") openHowToReadLink(e);
                    });
                }

                // badges replacement (disabled for now; kept for reference)
                // ;(function renderTopRightBadges() {
                //     const container = document.getElementById("top_right_badges");
                //     if (!container) return;
                //     container.innerHTML = "";
                //
                //     const make = (badge) => {
                //         const el = document.createElement("vis-badge");
                //         // `type`/`variant` are component props (not fields on `badge`).
                //         el.setAttribute("type", "mini");
                //         el.setAttribute("variant", "filled");
                //         el.badge = badge;
                //         return el;
                //     };
                //
                //     container.appendChild(make({
                //         label: "How to Read This",
                //         description: "This visualisation shows the trajectory of all formal agreements in peace processes from 1990-2024. The blue line represents how a peace process would look if it smoothly went from one stage to the next. However, processes do not tend to follow this linear pattern. Click the visualisation to start and see how processes go back and forth.",
                //         color: "rgb(2, 136, 209)",
                //         icon: "Info"
                //     }));
                //
                //     container.appendChild(make({
                //         label: "Data Up To Date",
                //         description: "This visualisation illustrates all processes in version 9 of the PA-X Peace Agreements Database, accessible from: www.peaceagreements.org.",
                //         color: "rgb(46, 125, 50)",
                //         icon: "Confirmation"
                //     }));
                //
                //     container.appendChild(make({
                //         label: "Data Creator(s) Attributed",
                //         description: "This visualisation shows the trajectory of all formal agreements in peace processes from 1990-2024. The blue line represents how a peace process would look if it smoothly went from one stage to the next. However, processes do not tend to follow this linear pattern. Click the visualisation to start and see how processes go back and forth.",
                //         color: "rgb(2, 136, 209)",
                //         icon: "badge-check"
                //     }));
                // })();

                const bottomRightBadgesRoot = document.getElementById("bottom_right_badges");
                let clickToToggleBadgeEl = null;

                const OPEN_DATA_URL = "https://www.peaceagreements.org";
                const OPEN_DATA_BADGE_DATA = {
                    label: "Open Data",
                    description: "Openly accessible PA-X data produced by the same peace and conflict research group. Click to open the database.",
                    actionIcon: "ExternalLink",
                    actionText: "click to open database",
                    color: "rgb(46, 125, 50)",
                    icon: "Confirmation"
                };

                function wireOpenDataClick(el) {
                    el.style.cursor = "pointer";
                    el.addEventListener("click", (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        window.open(OPEN_DATA_URL, "_blank", "noopener,noreferrer");
                    });
                }

                function setBottomRightBadgesVisible(visible) {
                    if (!bottomRightBadgesRoot) return;
                    bottomRightBadgesRoot.style.display = visible ? "flex" : "none";
                }

                function setClickToToggleBadgeVisible(visible) {
                    if (!clickToToggleBadgeEl) return;
                    clickToToggleBadgeEl.style.display = visible ? "" : "none";
                }

                function updateBottomRightBadgesPosition() {
                    if (!bottomRightBadgesRoot) return;
                    const svgEl = document.getElementById("svg");
                    if (!svgEl) return;
                    const plotRightViewBox = width - margin - 5;
                    const ctm = svgEl.getScreenCTM && svgEl.getScreenCTM();
                    if (!ctm || !svgEl.createSVGPoint) return;
                    const pt = svgEl.createSVGPoint();
                    pt.x = plotRightViewBox;
                    pt.y = 0;
                    const screenPt = pt.matrixTransform(ctm);
                    const rightOffset = Math.max(0, Math.round(window.innerWidth - screenPt.x));
                    bottomRightBadgesRoot.style.right = rightOffset + "px";
                }

                function initBottomRightBadges() {
                    if (!bottomRightBadgesRoot) return;

                    bottomRightBadgesRoot.innerHTML = "";
                    setBottomRightBadgesVisible(false);

                    const overlappingElementsBadge = document.createElement("vis-badge");
                    overlappingElementsBadge.setAttribute("type", "mini");
                    overlappingElementsBadge.setAttribute("variant", "filled");
                    overlappingElementsBadge.badge = {
                        type: "mini",
                        variant: "filled",
                        label: "Overlapping Elements",
                        description: "Overlaps are intentional and inevitable: many processes are shown on the same timeline to highlight how messy negotiations can be.",
                        color: "rgb(237, 108, 2)",
                        icon: "Warning"
                    };

                    const mindFalseConclusionsBadge = document.createElement("vis-badge");
                    mindFalseConclusionsBadge.setAttribute("type", "mini");
                    mindFalseConclusionsBadge.setAttribute("variant", "filled");
                    mindFalseConclusionsBadge.badge = {
                        type: "mini",
                        variant: "filled",
                        label: "Mind False Conclusions",
                        description: "Do not infer “success” from the line shape alone. Use this view to question assumptions, then consult the underlying context and evidence.",
                        color: "rgb(237, 108, 2)",
                        icon: "Warning"
                    };

                    const qualitativeCategoriesBadge = document.createElement("vis-badge");
                    qualitativeCategoriesBadge.setAttribute("type", "mini");
                    qualitativeCategoriesBadge.setAttribute("variant", "filled");
                    qualitativeCategoriesBadge.badge = {
                        type: "mini",
                        variant: "filled",
                        label: "Qualitative Categories",
                        description: "The y-axis shows qualitative negotiation stages (categories), not a numeric scale.",
                        color: "rgb(2, 136, 209)",
                        icon: "Info"
                    };

                    const clickToToggleBadge = document.createElement("vis-badge");
                    clickToToggleBadge.setAttribute("type", "mono");
                    clickToToggleBadge.setAttribute("variant", "filled");
                    clickToToggleBadge.badge = {
                        label: "Click on Peace Process",
                        description: "Click a process line to focus on that peace process. Click again or press Escape to return to the full view.",
                        color: "rgb(2, 136, 209)",
                        icon: "Interactive"
                    };
                    clickToToggleBadgeEl = clickToToggleBadge;
                    setClickToToggleBadgeVisible(true);

                    bottomRightBadgesRoot.appendChild(overlappingElementsBadge);
                    bottomRightBadgesRoot.appendChild(mindFalseConclusionsBadge);
                    bottomRightBadgesRoot.appendChild(qualitativeCategoriesBadge);
                    bottomRightBadgesRoot.appendChild(clickToToggleBadge);

                    updateBottomRightBadgesPosition();
                }

                initBottomRightBadges();
                window.addEventListener("resize", () => {
                    updateBottomRightBadgesPosition();
                });

                function clearURL() {
                    const url = new URL(window.location);
                    // Clear all search parameters
                    url.search = '';
                    // Update the URL without reloading the page
                    window.history.pushState({}, '', url);
                }


                d3.select(".button1").on("click", function () {
                    clearURL();
                    counter_collab = 0;
                    d3.select("#info")
                        .style("right", -305 + "px")

                    d3.selectAll(".idline").remove()
                    ideal.container.transition().duration(200).style("opacity", 1)
                    processPath
                        .attr("stroke-opacity", .05)
                        .attr("stroke-width", 1)
                        .attr("pointer-events", "none")
                    ideal.show = true;
                    setBottomRightBadgesVisible(false);
                    setClickToToggleBadgeVisible(true);
                    fixed = null;
                    $("#selUser").val(0).trigger('change');

                    /*svg.call(zoom).transition().duration(1500)
                            .call(zoom.transform,
                                d3.zoomIdentity
                                      .scale(1)
                                      .translate(0, 0)
                                );*/

                    circles.attr("opacity", 0).attr("pointer-events", "none")
                    d3.select("#main_title").html('Back and Forth in Peace Negotiations')
                    drawIdeal();
                })


                //Idealized process line
                drawIdeal();
                function drawIdeal() {
                    ideal.container = svg.append("g").attr("class", "ideal")

                    //draw line in plot
                    ideal.line = ideal.container.selectAll("path")
                        .data(data.ideal)
                        .enter()
                        .append("path")
                        .attr("fill-opacity", 0)
                        .attr("class", "idline")
                        .attr("stroke-width", 2)
                        .attr("stroke-opacity", 1)
                        .attr("stroke", "#0075FF")
                        .style("text-shadow", "1px 1px 2px black")
                        .attr("d", (d, i) => segment(d, i, scaleX))
                        .attr("pointer-events", "all")
                    //draw annotation
                    ideal.helper = ideal.container.append("text")
                        .attr("y", scaleY(3.2))
                        .attr("fill", "#0075FF")
                        .selectAll("tspan").data(["If peace negotiations went smoothly from one stage to the next,", "they would be represented by this blue line going steadily up.", "CLICK TO START"]).enter().append("tspan")
                        .text(d => d)
                        .attr("x", Math.round(scaleX(parseTime("2003-06-01"))))
                        .attr("dy", "12pt")
                        .attr("font-size", "13pt")
                        .style("font-weight", (d, i) => (i > 1) ? "bold" : "normal")
                        .attr("class", "idline")
                        .on("click", _ => toggleIdeal())

                    // badges under the CLICK TO START label (hide automatically when ideal.container is hidden)
                    const badgeBoxX = Math.round(scaleX(parseTime("2003-06-01")));
                    const badgeBoxY = scaleY(3.2) + 74;

                    const fo = ideal.container.append("foreignObject")
                        .attr("x", badgeBoxX)
                        .attr("y", badgeBoxY)
                        .attr("width", 420)
                        .attr("height", 160)
                        .attr("class", "idline");

                    const badgeRoot = fo.append("xhtml:div")
                        .style("display", "flex")
                        .style("flex-wrap", "wrap")
                        .style("gap", "8px")
                        .style("align-items", "center")
                        .style("max-width", "420px");

                    const openDataBadge = document.createElement("vis-badge");
                    openDataBadge.badge = OPEN_DATA_BADGE_DATA;
                    wireOpenDataClick(openDataBadge);

                    const rawDataBadge = document.createElement("vis-badge");
                    rawDataBadge.badge = {
                        type: "mini",
                        variant: "filled",
                        label: "Raw Data Available",
                        description: "Download the raw CSV used in this visualisation.",
                        actionIcon: "Download",
                        actionText: "click to download CSV",
                        color: "rgb(46, 125, 50)",
                        icon: "Confirmation"
                    };
                    rawDataBadge.style.cursor = "pointer";
                    rawDataBadge.addEventListener("click", async (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        try {
                            const res = await fetch("data/pax_all_agreements_v9.csv");
                            if (!res.ok) throw new Error(`Failed to fetch CSV (${res.status})`);
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement("a");
                            a.href = url;
                            a.download = "pax_all_agreements_v9.csv";
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                        } catch (err) {
                            console.error(err);
                        }
                    });

                    const overlappingElementsBadge = document.createElement("vis-badge");
                    overlappingElementsBadge.badge = {
                        type: "mini",
                        variant: "filled",
                        label: "Overlapping Elements",
                        description: "Overlaps are intentional and inevitable: many processes are shown on the same timeline to highlight how messy negotiations can be.",
                        color: "rgb(237, 108, 2)",
                        icon: "Warning"
                    };

                    const mindFalseConclusionsBadge = document.createElement("vis-badge");
                    mindFalseConclusionsBadge.badge = {
                        type: "mini",
                        variant: "filled",
                        label: "Mind False Conclusions",
                        description: "Do not infer “success” from the line shape alone. Use this view to question assumptions, then consult the underlying context and evidence.",
                        color: "rgb(237, 108, 2)",
                        icon: "Warning"
                    };

                    const canSortFilterBadge = document.createElement("vis-badge");
                    canSortFilterBadge.badge = {
                        type: "mini",
                        variant: "filled",
                        label: "Can Sort & Filter",
                        description: "You can filter by peace process using the dropdown at the top of the page.",
                        color: "rgb(2, 136, 209)",
                        icon: "Info"
                    };

                    const messyTimelineBadge = document.createElement("vis-badge");
                    messyTimelineBadge.badge = {
                        type: "mini",
                        variant: "filled",
                        label: "How to Read This",
                        description: "This visualisation shows the trajectory of all formal agreements in peace processes from 1990-2024. The blue line represents how a peace process would look if it smoothly went from one stage to the next. However, processes do not tend to follow this linear pattern. Click the visualisation to start and see how processes go back and forth.",
                        actionText: "click to start",
                        actionIcon: "Interactive",
                        color: "rgb(2, 136, 209)",
                        icon: "Info"
                    };
                    messyTimelineBadge.style.cursor = "pointer";
                    messyTimelineBadge.addEventListener("click", (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        toggleIdeal();
                    });

                    badgeRoot.node().appendChild(openDataBadge);
                    badgeRoot.node().appendChild(rawDataBadge);
                    badgeRoot.node().appendChild(overlappingElementsBadge);
                    badgeRoot.node().appendChild(mindFalseConclusionsBadge);
                    badgeRoot.node().appendChild(canSortFilterBadge);
                    badgeRoot.node().appendChild(messyTimelineBadge);

                    //draw example in explanation
                    ideal.example = d3.select("#ideal-example span").append("svg")
                        .attr("width", 20)
                        .attr("height", 12)
                        .on("mouseover", _ => toggleIdeal())
                        .on("mouseout", _ => toggleIdeal())
                        .append("path")
                        .attr("d", "M 1 11 C 10 11, 10 1, 20 1")
                        .attr("stroke", "#0075FF")
                        .attr("stroke-width", 2)
                        .attr("class", "idline")
                        .attr("fill", "transparent")
                }

                function toggleIdeal() {
                    if (ideal.show) {
                        ideal.container.style("opacity", 0).style("visibility", "hidden")
                        d3.select("#ideal-example").style("display", "block").style("opacity", 1)
                        processPath.attr("pointer-events", "all").attr("stroke-opacity", 9)
                        ideal.show = false;
                        setBottomRightBadgesVisible(true);
                    } else {
                        ideal.container.transition().duration(200).style("opacity", 1)
                        processPath.attr("stroke-opacity", .05)
                        ideal.show = true;
                        setBottomRightBadgesVisible(false);
                    }

                }

                // //INTERACTION
                // var zoom = d3.zoom()
                // 	.scaleExtent([0, 1])
                // 	.translateExtent([[0, 0], [width, height]])
                // 	.extent([[0, 0], [width, height]])
                // 	.on("zoom", zoomed);
                // svg.call(zoom)

                // function zoomed() {
                // 	var zoomScale = event.transform.rescaleX(scaleX)
                // 	years.call(xAxis.scale(zoomScale));
                // 	processPath.attr("d", (d, i) => segment(d, i, zoomScale))
                // 	circles.attr("cx", d => Math.round(zoomScale(parseTime(d.Dat))))
                // };

                document.onkeydown = function (e) {
                    if (e.key == "Escape") {
                        exitProcess();
                    }
                }

                processPath
                    .on("mousemove", function (d, i) {
                        highlightProcess(i)
                    })
                    .on("click", function (d, i) {
                        fixed ? exitProcess() : enterProcess(i.PP, i.PPName)
                    })
                    .on("mouseout", _ => highlightProcess())

                var highlightProcess = function (d, i) {
                    if (!fixed) {
                        if (d) {
                            processPath.attr("stroke-opacity", 0.05)
                            d3.selectAll("g.PP-" + d.PP + " path").attr("stroke-opacity", 1).attr("stroke-width", 2)
                            d3.select("#main_title").html(d.PPName)
                        } else {
                            processPath.attr("stroke-opacity", 1).attr("stroke-width", 1)
                            d3.select("#main_title").html('Back and Forth in Peace Negotiations')
                        }
                    }
                }

                //change URL based on selected country
                function updateURL(subset) {
                    const url = new URL(window.location);
                    url.searchParams.set('subset', subset);
                    window.history.pushState({}, '', url);
                }

                var enterProcess = function (id) {

                    if (ideal.show) toggleIdeal();
                    if (fixed) exitProcess();

                    let url_string = id
                    updateURL(url_string)

                    let nome = pax.find(d => d.PP == id)
                    let the_nome = nome.PPName


                    fixed = id
                    setClickToToggleBadgeVisible(false);
                    processPath.attr("stroke-opacity", 0.05)
                    d3.selectAll("g.PP-" + id + " path").attr("stroke-opacity", 1).attr("stroke-width", 3)
                    d3.selectAll("circle.PP-" + id).attr("opacity", .7).attr("pointer-events", "all")
                    d3.select("#main_title").html(the_nome)

                    var d0 = scaleX(parseTime(data[the_nome][0].Dat))
                    var d1 = scaleX(parseTime(data[the_nome][data[the_nome].length - 1].Dat))
                    var scale = width / (d1 - d0)

                    /*svg.call(zoom).transition().duration(1500)
                            .call(zoom.transform,
                                d3.zoomIdentity
                                    .translate(d0, 0)
                                        .scale(scale)
                                      );*/
                }

                if (ppid != null) {
                    enterProcess(ppid)
                }

                var exitProcess = function () {
                    clearURL()
                    fixed = null;
                    setClickToToggleBadgeVisible(true);
                    $("#selUser").val(0).trigger('change');

                    /*svg.call(zoom).transition().duration(1500)
                            .call(zoom.transform,
                                d3.zoomIdentity
                                      .scale(1)
                                      .translate(0, 0)
                                );*/

                    circles.attr("opacity", 0).attr("pointer-events", "none")
                    processPath.attr("stroke-opacity", .9).attr("stroke-width", 1)
                    d3.select("#main_title").html('Back and Forth in Peace Negotiations')
                }

                let hovno = Object.entries(data).map(function (d) {
                    return { 'name': d[0], "PP": d[1][0].PP }
                }).filter(d => d.name != "ideal")

                hovno.sort((a, b) => {
                    let nameA = a.name.toUpperCase();
                    let nameB = b.name.toUpperCase();
                    if (nameA < nameB) {
                        return -1;
                    }
                    if (nameA > nameB) {
                        return 1;
                    }
                    return 0;
                });

                d3.select("#selUser")
                    .selectAll("my_option")
                    .data(hovno)
                    .join("option")
                    .html(function (d) {
                        return `<option value="` + d.PP + `">` + d.name + `</option>`
                    })


                $(document).ready(function () {
                    // Initialize select2
                    $("#selUser").select2();
                    // Read selected option
                    $('#but_read').click(function () {
                        let username = $('#selUser option:selected').text();
                        let get_id = d3.filter(pax, function (d) {
                            return d.PPName == username
                        })
                        enterProcess(get_id[0].PP, username)
                    });
                });


            }

        }

    </script>
